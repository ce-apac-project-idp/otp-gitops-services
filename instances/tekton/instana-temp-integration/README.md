# README

# Aside

Please note you will find all these resources (Tasks, pipelines, configmaps etc..) in the "backstage" namespace, NOT "tekton".


# Procedure

The relevant artefacts can be found in the task and pipeline folder. 

In order, the pipeline executes the following:

1) bp-task
2) image-checker
3) image-scanner
4) image-deployer


Bp-task executes the following:

1) Creates a build config pertaining to the app (if necessary) and uses the provided params in addition to the configmap workspace (this is a configmap called registry-data) to populate the build config. This will contain the output docker registry and the input Dockerfile source, in addition to pointers to the k8 secrets required to pull and push from the git repo and docker registry respectively. There is a dummy buildconfig file baked in the image and I use yq to perform the substitutions. I start and wait for the build to finish. Once the build is commplete I query the relevant build to obtain the image and sha, which are passed to the downstream tasks.

An example BuildConfig and build generated by this task can be found in the samples directory.

Image-checker executes the following:

1) Performs a roxctl image check using the image and sha obtained from the upstream task.
2) The roxctl binary is baked into the image, so no curl'ing required here, nor is the utility used to obtain the SHA.

Image-scanner is very similar to the above task, except the scan command, as opposed to check, is run.

Image-deployer executes the following:

1) The task will create a deployment.yaml using the image and sha obtained from earlier tasks. (Yes I need to mmaking services and routes as well but this is to be done later)
2) It will then push this
3) It uses the git-data configmap which contains info about the git repo to push to. (ArgoCD then takes care of the rest from there)

An example pipelinerun can be found in the samples directory too.


# Additional Information

## ConfigMap/Secret Injection

Hardcoded values should be avoided where possible, please externalise non sensitive values to configmaps and sensitive values as secrets. Assumming we have a bunch of values we wish to externalise (Say, instana_server and instana_endpoint in the tekton task) we can include them within a configmap called "instana-data" (Recall I have a git-data and registry-data configmap as well for the same purpose)

Introduce them to as a entry in the workspaces stanza of pipeline.yaml. You will notice that there is a pipeline directory in this folder. the Workspaces stanza contains, amongst others, the aforementioned reg-data and git-data configmaps referred to, within the context of the pipeline, as registry-configmap and git-configmap respectively.

They are "referenced" in the pipelinerun object. I have provided a pipelinerun spec in the samples directory. Look at the workspaces stanza. Registry-data and git-data are defined there and mapped to the registry-configmap and git-configmap respectively.

Referencing them in the tasks is quite simple. Look at "bp-task" within the task directory. Specifically, lines 85-88 (inclusive). Each parameter is defined in a file found within /workspace/name_of_cmap/name_of_parameter_here. 

Please take care with name_of_cmap_here, this is the name of the cmap **within the scope of the task**. Look at lines 11 and 12 of this very task. The name is defined there on the task level and defined in line 44 at the pipeline level.

The same can be applied for secrets.

## RHACS integration

We use RHACS to perform the image checks and scan prior to deployment. We invoke RHACS scans through an API driven fashion. The processes running in our tekton tasks are effectively our RHACS clients. And our RHACS instance will then perform the calls on our behalf. On a high level, the flow is as such:

RHACS client (tekton task) -> RHACS instance -> Remote registry (public/private) -> RHACS instance -> RHACS client

Depending on the call, results can be persisted at the data layer (not shown above)

To this end, the client requires:

1) The RHACS binary
2) A means of authenticating to the instance

We have baked the binary (called roxctl) on a redhat universal image within the Dockerfile. Please refer to this [README](LINK_HERE) for more information.

Authenticating to the instance is quite simple, roxctl assumes an environment variable called [ROX_API_TOKEN](https://docs.openshift.com/acs/3.73/cli/getting-started-cli.html#cli-authentication_cli-getting-started) be accessible within the user session. The token was made a secret in the cluster and introduced to the task by means of an environment variable. The tasks, image-scanner and image-checker within the tasks directory shed more light onto this. It is relatively straightforward to see how said secret is injected and rendered an environment variable. 

The [link](https://docs.openshift.com/acs/3.73/cli/getting-started-cli.html#cli-authentication_cli-getting-started) given above discusses how one can generate said api token. Ensure you copy this and save it directly to your cluster as a secret. You may wish to save this within your organisations's chosen external secret provider and use K8's [ExternalSecret](https://external-secrets.io/v0.7.2/) framework to ingest this, or perhaps via the [SealedSecrets](https://github.com/bitnami-labs/sealed-secrets) framework.

Recall, the RHACS instance performs the requests (eg, image scans) on the behalf of the client and, as such, requires authentication and authorisation be configured beforehand in the event your registry is private. You may wish to stop here in the event your instance is public, or perhaps reconsider your decision and set it to private.

Configuring authn and authz is given [here](https://docs.openshift.com/acs/3.73/integration/integrate-with-image-registries.html#manual-configuration-image-registry). Various registries are supported, including, but not limited to:

1) Amazon ECR
2) Azure Container Registry
3) JFrog Artifactory

In our instance, our external registry was Quay. As such, we followed the instructions given [here](https://docs.openshift.com/acs/3.73/integration/integrate-with-image-registries.html#manual-configuration-image-registry-qcr_integrate-with-image-registries). Unfortunately, the instructions given here is rather incomplete. One would assume having a Quay integration of type "Registry + Scanner" should suffice. This, unfortunately, is incorrect. Two sets of integrations are required. One of type "registry" and one of type "registry + scanner". Furthermore, two sets of distinct credentials are required for the "Registry + Scanner" integration. That is, one OAuth Token and a Robot Account. One would assume the robot account performs the authn while the OAuth token is required for authz. But this is simply not true. A Robot account is configured againsr certain repositories in Quay (which is essentially authz).

To sum up, the following is required:

1) One Quay integration of type "Registry + Scanner". Provide BOTH an OAuth Token and a Robot account (both can be generated from the Quay UI)
2) One Quay integration of type "Registry". Provide a Robot account credentials here.

Robot accounts can only be configured against existant registries, they cannot, unfortunately, be configured against Quay orgs. There is no means to associate a robot account with a registry programmatically. As such the robot account used was my very own quay creds., It would be incumbent for Quay to support a feature such as this.

### Gotchas

1) The buildConfig task responsible for performing the image push was set to a public organisation (registry) in Quay. That said, the resulting image defaults to private, clearly exceeding the maximum amount of private registries (which is 0 in our case). This is likely a bug on the Quay end.
2) Why are two sets of credentials required for scanning private Quay registries. Both an OAuth Token and a Robot Account is required for the "Registry + Scanner" type, as opposed to either one of them.
3) Why are two different Quay integrations required. That is, one "Registry" and one "Registry + Scanner" integration. We wrongfully assumed
4) Round robin behaviour noted if two integrations are used. If one is configured correctly and the other is configured incorrectly, only 50% of image scans actually proceed. This is due to the apparent round robin behaviour.

